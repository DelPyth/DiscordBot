#NoEnv
#SingleInstance, Force
#MaxThreadsPerHotkey, 1
#MaxHotkeysPerInterval, 9900000
#KeyHistory, 0
#Persistent
; #NoTrayIcon
ListLines, Off
SendMode, Input
SetBatchLines -1
SetWinDelay, -1
SetMouseDelay, -1
SetKeyDelay, -1, -1
SetTitleMatchMode, 3
DetectHiddenWindows, On
SetWorkingDir, % A_ScriptDir

; Include Discord.ahk
#Include <Debug>
#Include %A_ScriptDir%\Lib\
#Include Discord.ahk

; Include RemoteObj.ahk and its dependencies
#Include RemoteObj.ahk
#Include WebSocket.ahk
#Include Jxon.ahk

; Super-global configuration constants
global EMOJI_REFRESH := Chr(9851)
global EMOJI_DELETE  := Chr(10060)
global ADMIN_USERS   := { 123456: True }
global HELP_FILE     := "HelpText.md"

; Read the token file
if (!Token := FileOpen(A_ScriptDir "\token.txt", "r").Read())
	throw Exception("Failed to load token!")

FileAppend, [%A_Now%]: Script started`r`n, UptimeLog.txt

; Attempt to connect to server
loop {
	Sleep, 3000
	try
		Bot := new DiscordBot(Token)
	catch e {
		; Server address could not be resolved
		if (e.message ~= "^0x80072EE7")
			continue
		throw e
	}
	break
}

FileAppend, [%A_Now%]: Connected`r`n, UptimeLog.txt

; Expose the plugin API
Server := new RemoteObj(new PluginAPI(bot), ["10.10.10.1", 1337])

; Handle script close gracefully
OnExit, ExitSub
return

ExitSub:
	Bot.ws.Close()
	ExitApp
	return

class PluginAPI {
	__New(DiscordInstance) {
		this.DiscordInstance := DiscordInstance
	}

	Repeat(Results, Context) {
		For Index, Result in Results
			Content .= Context.TriggerID "`n" StrReplace(Result, "``", "'") " `n`n"

		m(Context)
		This.DiscordInstance.SendMessage(Context.ChannelID, Content)
	}

	Results(Results, Context) {
		; Build the message content
		Content := ""
		for Index, Result in Results
			Content .= "``````" Context.TriggerID "`n" StrReplace(Result, "``", "'") " `n```````n"
		Content .= "_Response to <@" Context.AuthorID ">'s message. "
		Content .= ":x: to delete. :recycle: to re-run._"

		; Create/Edit the message
		if (Context.MessageID) {
			Message := this.DiscordInstance.CallAPI("PATCH"
				, "/channels/" Context.ChannelID
				. "/messages/" Context.MessageID
				, {"content": Content})
		}
		else
			Message := this.DiscordInstance.SendMessage(Context.ChannelID, Content)

		; Add the emoji buttons
		EmojiPath := "/channels/" Message.channel_id "/messages/" Message.id "/reactions/{}/@me"
		this.DiscordInstance.CallAPI("PUT", Format(EmojiPath, EMOJI_DELETE))
		this.DiscordInstance.CallAPI("PUT", Format(EmojiPath, EMOJI_REFRESH))
	}
}

class DiscordBot extends Discord {
	; Holds messages that may need to be looked up
	MessageBuffer := {}

	; Checks if a message is available in the buffer
	InBuffer(ChannelID, MessageID) {
		return this.MessageBuffer.HasKey(ChannelID " " MessageID)
	}

	; Finds a message from the cache or requests from the server
	GetMessage(ChannelID, MessageID) {
		if !this.MessageBuffer[ChannelID " " MessageID] {
			; TODO: Handle invalid/deleted message IDs
			Message := this.CallAPI("GET"
				, "/channels/" ChannelID "/messages/" MessageID)

			this.MessageBuffer[Message.channel_id " " Message.id] := Message
		}

		return this.MessageBuffer[ChannelID " " MessageID]
	}

	; Finds or creates a reaction on a message
	GetReaction(ChannelID, MessageID, EmojiName) {
		; Get the reactions array
		Message := this.GetMessage(ChannelID, MessageID)
		if !Message.reactions
			Message.reactions := []

		; Find existing reaction if present
		for Index, Reaction in Message.reactions
			if (Reaction.emoji.name == EmojiName)
				return Reaction

		; Create a new reaction
		Emoji := { "id": "", "name": EmojiName }
		Reaction := { "count": 0, "me": False, "emoji": Emoji }
		Message.reactions.push(Reaction)
		return Reaction
	}

	; Log all incoming data
	OnMessage(Event) {
		Print("<", Event.data)
		return Discord.OnMessage.Call(this, Event)
	}

	; Log all outgoing data
	Send(Data) {
		Print(">", Data)
		return Discord.Send.Call(this, Data)
	}

	OP0_READY(Data) {
		this.user := Data.user
		FileAppend, [%A_Now%]: Received OP0_READY`r`n, UptimeLog.txt
	}

	OP0_MESSAGE_CREATE(Data) {
		; Cache the message for later lookups
		this.MessageBuffer[Data.channel_id " " Data.id] := Data

		; Ignore messages generated by ourself
		if (Data.author.id == this.user.id)
			return

		if (Trim(Data.content, " `t`r`n") ~= "^\" BOT_PREFIX) {
			CommandName		:= RegExReplace(Data.content	, "^\" BOT_PREFIX)
			Params			:= RegExReplace(CommandName		, "^[\w\_]+")

			PluginAPI[CommandName](Params)
		}

		; Handle reload messages
		if (ADMIN_USERS[Data.author.id] && InStr(Data.content, EMOJI_REFRESH)) {
			this.CallAPI("DELETE", "/channels/" Data.channel_id "/messages/" Data.id)
			reload
		}

		; Handle help requests
		if (Trim(Data.content, " `t`r`n") ~= "^<@\d+>\s*help$") {
			; Send the help template
			Message := this.SendMessage(Data.channel_id
				, "<@" Data.author.id "> " FileOpen(HELP_FILE, "r").Read())

			; Add an emoji delete button
			this.CallAPI("PUT", "/channels/" Message.channel_id
				. "/messages/" Message.id "/reactions/" EMOJI_DELETE "/@me")
			return
		}
	}

	OnError() {
		FileAppend, [%A_Now%]: Websocket Error`r`n, UptimeLog.txt
	}

	OnClose(Event) {
		FileAppend, [%A_Now%]: Websocket Close`,`nReloading...`r`n, UptimeLog.txt
		reload
	}
}

Print(Params*){
	static _ := DllCall("AllocConsole") ; Allocate a console
	, ConOut := FileOpen("CONOUT$", "w") ; Get a handle to the console output

	; Output the parameters to the console
	for k, v in Params
		ConOut.Write((IsObject(v) ? Discord.Jxon_Dump(v) : v) "`t")

	; End with a newline then flush the buffer with __Handle
	ConOut.Write("`n"), ConOut.__Handle
}

Run(Params*) {
	for each, Param in Params {
		if IsObject(Param)
			Param := Discord.Jxon_Dump(Param)
		RunStr .= """" RegExReplace(Param, "(\\*)""", "$1$1\""") """ "
	}
	Run, %RunStr%
}

FindCodeBlocks(Message) {
	static Needle :=
	(LTrim Join Comments
		"OJsi`a)
		(?<!\\)(?:\\\\)* ; Don't match escaped blocks
		(?:
			`````` ; Triple enclosed block
			(?P<Lang>[a-z0-9]+\R)? ; Optional language
			(?P<Code>.+?)
			``````
			|
			```` ; Double enclosed block
			(?P<Inline>.+?)
			(?<!``)````(?!``)
			|
			`` ; Single enclosed block
			(?P<Inline>.+?)
			(?<!``)``(?!``)
		())"
	)

	Blocks := [], Pos := 1
	while Pos := RegExMatch(Message, Needle, Match, Pos)
		Blocks.Push(Match.Inline ? "Result:=" Match.Inline : Match.Code), Pos += Match.Len()
	return Blocks.Length() ? Blocks : False
}
